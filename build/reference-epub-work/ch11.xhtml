<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 11. Common Batch Patterns</title><link rel="stylesheet" type="text/css" href="docbook-epub.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"/><link rel="prev" href="ch10s06.xhtml" title="Mocking Domain Objects"/><link rel="next" href="ch11s02.xhtml" title="Stopping a Job Manually for Business Reasons"/></head><body><header/><section class="chapter" title="Chapter 11. Common Batch Patterns" epub:type="chapter" id="patterns"><div class="titlepage"><div><div><h1 class="title">Chapter 11. Common Batch Patterns</h1></div></div></div>

  

  <p>Some batch jobs can be assembled purely from off-the-shelf components
  in Spring Batch. For instance the <code class="classname">ItemReader</code> and
  <code class="classname">ItemWriter</code> implementations can be configured to cover
  a wide range of scenarios. However, for the majority of cases, custom code
  will have to be written. The main API entry points for application
  developers are the <code class="classname">Tasklet</code>,
  <code class="classname">ItemReader</code>, <code class="classname">ItemWriter</code> and the
  various listener interfaces. Most simple batch jobs will be able to use
  off-the-shelf input from a Spring Batch <code class="classname">ItemReader</code>,
  but it is often the case that there are custom concerns in the processing
  and writing, which require developers to implement an
  <code class="classname">ItemWriter</code> or
  <code class="classname">ItemProcessor</code>.</p>

  <p>Here, we provide a few examples of common patterns in custom business
  logic. These examples primarily feature the listener interfaces. It should
  be noted that an <code class="classname">ItemReader</code> or
  <code class="classname">ItemWriter</code> can implement a listener interface as
  well, if appropriate.</p>

  <section class="section" title="Logging Item Processing and Failures" epub:type="subchapter" id="loggingItemProcessingAndFailures"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Logging Item Processing and Failures</h2></div></div></div>
    

    <p>A common use case is the need for special handling of errors in a
    step, item by item, perhaps logging to a special channel, or inserting a
    record into a database. A chunk-oriented <code class="classname">Step</code>
    (created from the step factory beans) allows users to implement this use
    case with a simple <code class="classname">ItemReadListener</code>, for errors on
    read, and an <code class="classname">ItemWriteListener</code>, for errors on
    write. The below code snippets illustrate a listener that logs both read
    and write failures:</p>

    <pre class="programlisting">public class ItemFailureLoggerListener extends ItemListenerSupport {

    private static Log logger = LogFactory.getLog("item.error");

    public void onReadError(Exception ex) {
        logger.error("Encountered error on read", e);
    }

    public void onWriteError(Exception ex, Object item) {
        logger.error("Encountered error on write", ex);
    }

}</pre>

    <p>Having implemented this listener it must be registered with the
    step:</p>

    <pre class="programlisting">&lt;step id="simpleStep"&gt;
    ...
    &lt;listeners&gt;
        &lt;listener&gt;
            &lt;bean class="org.example...ItemFailureLoggerListener"/&gt;
        &lt;/listener&gt;
    &lt;/listeners&gt;
&lt;/step&gt;</pre>

    <p>Remember that if your listener does anything in an
    <code class="code">onError()</code> method, it will be inside a transaction that is
    going to be rolled back. If you need to use a transactional resource such
    as a database inside an <code class="code">onError()</code> method, consider adding a
    declarative transaction to that method (see Spring Core Reference Guide
    for details), and giving its propagation attribute the value
    REQUIRES_NEW.</p>
  </section>

  

  

  

  

  

  

  
</section><footer/></body></html>