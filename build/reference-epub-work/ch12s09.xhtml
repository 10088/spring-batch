<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Scaling a JSR-352 batch job</title><link rel="stylesheet" type="text/css" href="docbook-epub.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"/><link rel="prev" href="ch12s08.xhtml" title="Step Flow"/><link rel="next" href="ch12s10.xhtml" title="Testing"/></head><body><header/><section class="section" title="Scaling a JSR-352 batch job" epub:type="subchapter" id="jsrScaling"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Scaling a JSR-352 batch job</h2></div></div></div><p>Traditional Spring Batch jobs have four ways of scaling (the last two capable of being executed across
            multiple JVMs):
            </p><div class="itemizedlist" epub:type="list"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem" epub:type="list-item"><p>Split - Running multiple steps in parallel.</p></li><li class="listitem" epub:type="list-item"><p>Multiple threads - Executing a single step via multiple threads.</p></li><li class="listitem" epub:type="list-item"><p>Partitioning - Dividing the data up for parallel processing (master/slave).</p></li><li class="listitem" epub:type="list-item"><p>Remote Chunking - Executing the processor piece of logic remotely.</p></li></ul></div><p>
        </p><p>JSR-352 provides two options for scaling batch jobs.  Both options support only a single JVM:
            </p><div class="itemizedlist" epub:type="list"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem" epub:type="list-item"><p>Split - Same as Spring Batch</p></li><li class="listitem" epub:type="list-item"><p>Partitioning - Conceptually the same as Spring Batch however implemented slightly different.
                    </p></li></ul></div><p>
        </p><section class="section" title="Partitioning" epub:type="division" id="jsrPartitioning"><div class="titlepage"><div><div><h3 class="title">Partitioning</h3></div></div></div><p>Conceptually, partitioning in JSR-352 is the same as it is in Spring Batch.  Meta-data is provided
                to each slave to identify the input to be processed with the slaves reporting back to the master the
                results upon completion.  However, there are some important differences:
                </p><div class="itemizedlist" epub:type="list"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem" epub:type="list-item"><p>Partitioned <code class="classname">Batchlet</code> - This will run multiple instances of the
                            configured <code class="classname">Batchlet</code> on multiple threads.  Each instance will have
                            it's own set of properties as provided by the JSL or the
                            <code class="classname">PartitionPlan</code></p></li><li class="listitem" epub:type="list-item"><p><code class="classname">PartitionPlan</code> - With Spring Batch's partitioning, an
                            <code class="classname">ExecutionContext</code> is provided for each partition.  With JSR-352, a
                            single <code class="classname">javax.batch.api.partition.PartitionPlan</code> is provided with an
                            array of <code class="classname">Properties</code> providing the meta-data for each partition.
                        </p></li><li class="listitem" epub:type="list-item"><p><code class="classname">PartitionMapper</code> - JSR-352 provides two ways to generate partition
                            meta-data.  One is via the JSL (partition properties).  The second is via an implementation
                            of the <code class="classname">javax.batch.api.partition.PartitionMapper</code> interface.
                            Functionally, this interface is similar to the
                            <code class="classname">org.springframework.batch.core.partition.support.Partitioner</code>
                            interface provided by Spring Batch in that it provides a way to programmaticaly generate
                            meta-data for partitioning.</p></li><li class="listitem" epub:type="list-item"><p><code class="classname">StepExecution</code>s - In Spring Batch, partitioned steps are run as
                            master/slave. Within JSR-352, the same configuration occurs.  However, the slave steps do
                            not get official <code class="classname">StepExecution</code>s.  Because of that, calls to
                            <code class="classname">JsrJobOperator#getStepExecutions(long jobExecutionId)</code> will only
                            return the <code class="classname">StepExecution</code> for the master.  </p><div class="note" title="Note" epub:type="notice"><table style="border: 0; "><tr><td style="text-align: center; vertical-align: top; width: 25; " rowspan="2"><img alt="[Note]" src="images/note.png"/></td><th style="text-align: left; ">Note</th></tr><tr><td style="text-align: left; vertical-align: top; "><p>The child
                            <code class="classname">StepExecution</code>s still exist in the job repository and are available
                            via the <code class="classname">JobExplorer</code> and Spring Batch Admin.</p></td></tr></table></div><p>
                        </p></li><li class="listitem" epub:type="list-item"><p>Compensating logic - Since Spring Batch implements the master/slave logic of
                            partitioning using steps, <code class="classname">StepExecutionListener</code>s can be used to
                            handle compensating logic if something goes wrong.  However, since the slaves JSR-352
                            provides a collection of other components for the ability to provide compensating logic when
                            errors occur and to dynamically set the exit status.  These components include the following:
                            </p><div class="informaltable"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col style="text-align: left; "/><col style="text-align: left; "/></colgroup><tbody><tr><td style="text-align: left; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                                                <span class="bold"><strong>Artifact Interface</strong></span>
                                            </td><td style="text-align: left; border-bottom: 0.5pt solid ; ">
                                                <span class="bold"><strong>Description</strong></span>
                                            </td></tr><tr><td style="text-align: left; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">javax.batch.api.partition.PartitionCollector</code></td><td style="text-align: left; border-bottom: 0.5pt solid ; ">Provides a way for slave steps to send information back to the
                                                master.  There is one instance per slave thread.</td></tr><tr><td style="text-align: left; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="classname">javax.batch.api.partition.PartitionAnalyzer</code></td><td style="text-align: left; border-bottom: 0.5pt solid ; ">End point that receives the information collected by the
                                                <code class="classname">PartitionCollector</code> as well as the resulting
                                                statuses from a completed partition.</td></tr><tr><td style="text-align: left; border-right: 0.5pt solid ; "><code class="classname">javax.batch.api.partition.PartitionReducer</code></td><td style="text-align: left; ">Provides the ability to provide compensating logic for a partitioned
                                                step.</td></tr></tbody></table></div><p>
                        </p></li></ul></div><p>
            </p></section></section><footer/></body></html>