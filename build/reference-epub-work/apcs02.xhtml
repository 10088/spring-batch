<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Simple Stateless Retry</title><link rel="stylesheet" type="text/css" href="docbook-epub.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"/><link rel="prev" href="apc.xhtml" title="Appendix C. Batch Processing and Transactions"/><link rel="next" href="apcs03.xhtml" title="Typical Repeat-Retry Pattern"/></head><body><header/><section class="section" title="Simple Stateless Retry" epub:type="division" id="transactionStatelessRetry"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Simple Stateless Retry</h2></div></div></div><p>It is also useful to use a retry for an operation which is not
			transactional, like a call to a web-service or other remote
			resource.  For example:</p><pre class="programlisting">
0   |  TX {
1   |    input;
1.1 |    output;
2   |    RETRY {
2.1 |      remote access;
|    }
|  }
		</pre><p>This is actually one of the most useful applications of a retry,
			since a remote call is much more likely to fail and be retryable
			than a database update.  As long as the remote access (2.1)
			eventually succeeds, the transaction TX(0) will commit.  If the
			remote access (2.1) eventually fails, then the transaction TX(0) is
			guaranteed to roll back.</p></section><footer/></body></html>